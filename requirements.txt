Django==4.2.7
beautifulsoup4==4.12.2
requests==2.31.0
numpy==1.26.0
pandas==2.1.0
matplotlib==3.7.2
seaborn==0.12.2
scikit-learn==1.3.0
prophet==1.1.4
selenium==4.15.2
celery==5.3.4
python-decouple==3.8
Pillow==10.0.1
lxml==4.9.3
fake-useragent==1.4.0

dashbord.html

{% extends 'tracker/base.html' %}

{% block title %}Dashboard - Price Tracker{% endblock %}

{% block content %}
<div class="row">
    <!-- Statistics Cards -->
    <div class="col-md-3 mb-4">
        <div class="card card-stats bg-primary text-white">
            <div class="card-body">
                <div class="d-flex justify-content-between">
                    <div>
                        <h3 class="card-title">{{ total_products }}</h3>
                        <p class="card-text">Total Products</p>
                    </div>
                    <div class="align-self-center">
                        <i class="fas fa-box fa-2x"></i>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="col-md-3 mb-4">
        <div class="card card-stats bg-success text-white">
            <div class="card-body">
                <div class="d-flex justify-content-between">
                    <div>
                        <h3 class="card-title">{{ active_products }}</h3>
                        <p class="card-text">Active Products</p>
                    </div>
                    <div class="align-self-center">
                        <i class="fas fa-check-circle fa-2x"></i>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="col-md-3 mb-4">
        <div class="card card-stats bg-warning text-white">
            <div class="card-body">
                <div class="d-flex justify-content-between">
                    <div>
                        <h3 class="card-title">{{ products_with_alerts }}</h3>
                        <p class="card-text">Products with Alerts</p>
                    </div>
                    <div class="align-self-center">
                        <i class="fas fa-bell fa-2x"></i>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="col-md-3 mb-4">
        <div class="card card-stats bg-info text-white">
            <div class="card-body">
                <div class="d-flex justify-content-between">
                    <div>
                        <h3 class="card-title">{{ successful_scrapes }}</h3>
                        <p class="card-text">Today's Updates</p>
                    </div>
                    <div class="align-self-center">
                        <i class="fas fa-sync fa-2x"></i>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Bulk Update Button -->
<div class="row mb-4">
    <div class="col-12">
        <div class="card">
            <div class="card-body">
                <div class="d-flex justify-content-between align-items-center">
                    <h5 class="card-title mb-0">Price Updates</h5>
                    <form method="post" action="{% url 'tracker:bulk_update_prices' %}" style="display: inline;">
                        {% csrf_token %}
                        <button type="submit" class="btn btn-primary" onclick="return confirm('This will update prices for all active products. This may take several minutes. Continue?')">
                            <i class="fas fa-sync"></i> Update All Prices
                        </button>
                    </form>
                </div>
                <small class="text-muted">Last successful scrapes today: {{ successful_scrapes }} / {{ today_scrapes }}</small>
            </div>
        </div>
    </div>
</div>

<!-- Recent Price Changes -->
{% if recent_changes %}
<div class="row mb-4">
    <div class="col-12">
        <div class="card">
            <div class="card-header">
                <h5 class="card-title mb-0">Recent Price Changes (7 days)</h5>
            </div>
            <div class="card-body">
                <div class="row">
                    {% for change in recent_changes %}
                        <div class="col-md-4 mb-3">
                            <div class="card border-left-{% if change.is_positive %}success{% else %}danger{% endif %}">
                                <div class="card-body">
                                    <h6 class="card-title">{{ change.product.name|truncatechars:25 }}</h6>
                                    <p class="card-text">
                                        <span class="badge {% if change.is_positive %}bg-success{% else %}bg-danger{% endif %}">
                                            {% if change.is_positive %}+{% endif %}{{ change.change_percentage|floatformat:2 }}%
                                        </span>
                                        <small class="text-muted">in 7 days</small>
                                    </p>
                                </div>
                            </div>
                        </div>
                    {% endfor %}
                </div>
            </div>
        </div>
    </div>
</div>
{% endif %}

<!-- Products Table -->
<div class="row">
    <div class="col-12">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="card-title mb-0">Your Products</h5>
                <a href="{% url 'tracker:add_product' %}" class="btn btn-primary">Add Product</a>
            </div>
            <div class="card-body">
                {% if products %}
                    <div class="table-responsive">
                        <table class="table table-hover">
                            <thead class="table-light">
                                <tr>
                                    <th>Product</th>
                                    <th>Current Price</th>
                                    <th>Price Change</th>
                                    <th>Last Updated</th>
                                    <th>Status</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for product in products %}
                                    <tr>
                                        <td>
                                            <strong>{{ product.name|truncatechars:40 }}</strong>
                                            <br>
                                            <small class="text-muted">{{ product.currency }}</small>
                                        </td>
                                        <td>
                                            {% if product.current_price %}
                                                <strong>{{ product.current_price }}</strong>
                                            {% else %}
                                                <span class="text-muted">No data</span>
                                            {% endif %}
                                        </td>
                                        <td>
                                            <span class="text-muted">N/A</span>
                                        </td>
                                        <td>
                                            {% if product.last_scraped %}
                                                {{ product.last_scraped|timesince }} ago
                                            {% else %}
                                                <span class="text-muted">Never</span>
                                            {% endif %}
                                        </td>
                                        <td>
                                            {% if product.is_active %}
                                                <span class="badge bg-success">Active</span>
                                            {% else %}
                                                <span class="badge bg-secondary">Inactive</span>
                                            {% endif %}
                                        </td>
                                        <td>
                                            <div class="btn-group btn-group-sm">
                                                <a href="{% url 'tracker:product_detail' product.pk %}" 
                                                   class="btn btn-outline-info">View</a>
                                                <a href="{% url 'tracker:edit_product' product.pk %}" 
                                                   class="btn btn-outline-warning">Edit</a>
                                                <form method="post" action="{% url 'tracker:update_price_manual' product.id %}" style="display: inline;">
                                                    {% csrf_token %}
                                                    <button type="submit" class="btn btn-outline-success btn-sm" 
                                                            title="Update Price" onclick="return confirm('Update price for {{ product.name }}?')">
                                                        <i class="fas fa-sync"></i> Update
                                                    </button>
                                                </form>
                                                <button onclick="toggleProductStatus('{{ product.id }}')" 
                                                        class="btn btn-outline-secondary btn-sm">
                                                    {% if product.is_active %}Disable{% else %}Enable{% endif %}
                                                </button>
                                            </div>
                                        </td>
                                    </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                    </div>

                    <!-- Pagination -->
                    {% if is_paginated %}
                        <nav aria-label="Products pagination">
                            <ul class="pagination justify-content-center">
                                {% if page_obj.has_previous %}
                                    <li class="page-item">
                                        <a class="page-link" href="?page=1">&laquo; First</a>
                                    </li>
                                    <li class="page-item">
                                        <a class="page-link" href="?page={{ page_obj.previous_page_number }}">Previous</a>
                                    </li>
                                {% endif %}

                                <li class="page-item active">
                                    <span class="page-link">
                                        Page {{ page_obj.number }} of {{ page_obj.paginator.num_pages }}
                                    </span>
                                </li>

                                {% if page_obj.has_next %}
                                    <li class="page-item">
                                        <a class="page-link" href="?page={{ page_obj.next_page_number }}">Next</a>
                                    </li>
                                    <li class="page-item">
                                        <a class="page-link" href="?page={{ page_obj.paginator.num_pages }}">Last &raquo;</a>
                                    </li>
                                {% endif %}
                            </ul>
                        </nav>
                    {% endif %}
                {% else %}
                    <div class="text-center py-5">
                        <h4>No products found</h4>
                        <p class="text-muted">Start tracking your first product to see it here.</p>
                        <a href="{% url 'tracker:add_product' %}" class="btn btn-primary">Add Your First Product</a>
                    </div>
                {% endif %}
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
// Toggle product status
function toggleProductStatus(productId) {
    fetch(`/product/${productId}/toggle-status/`, {
        method: 'POST',
        headers: {
            'X-CSRFToken': document.querySelector('[name=csrfmiddlewaretoken]').value,
            'Content-Type': 'application/json',
        },
    })
    .then(response => response.json())
    .then(data => {
        if (data.status === 'success') {
            location.reload();
        } else {
            alert('Error updating product status: ' + data.message);
        }
    })
    .catch(error => {
        alert('Error updating product status');
    });
}
</script>
{% endblock %}

utils.py

"""
Utility functions for the Price Tracker application.
"""

import requests
import time
import logging
import re
import io
import base64
import signal
from datetime import datetime, timedelta
from decimal import Decimal
from typing import Optional, Dict, List, Tuple, Any
import json

# Web scraping imports
from bs4 import BeautifulSoup
from fake_useragent import UserAgent
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from selenium.common.exceptions import TimeoutException, NoSuchElementException, WebDriverException

# Data processing imports
import numpy as np
import pandas as pd

# Machine Learning imports
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_absolute_error, r2_score

# Prophet for time series forecasting
try:
    from prophet import Prophet
    PROPHET_AVAILABLE = True
except ImportError:
    PROPHET_AVAILABLE = False
    logging.warning("Prophet not available. Using simple regression models only.")

# Visualization imports
import matplotlib
matplotlib.use('Agg')  # Use non-interactive backend
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import seaborn as sns

# Django imports
from django.utils import timezone
from django.conf import settings
from django.core.mail import send_mail
from django.template.loader import render_to_string
from django.utils.html import strip_tags

# Set up logging
logger = logging.getLogger(__name__)

# Configure matplotlib and seaborn
plt.style.use('default')
sns.set_palette("husl")
plt.rcParams['figure.figsize'] = (12, 6)
plt.rcParams['figure.dpi'] = 100
plt.rcParams['font.size'] = 10


class TimeoutError(Exception):
    """Custom timeout error for scraping operations."""
    pass


def timeout_handler(signum, frame):
    """Signal handler for timeout operations."""
    raise TimeoutError("Operation timed out")


class WebScraper:
    """Enhanced web scraping utility class."""
    
    def __init__(self):
        """Initialize the scraper with configuration and user agents."""
        self.session = requests.Session()
        
        try:
            self.ua = UserAgent()
            self.user_agent = self.ua.random
        except:
            # Fallback user agent if fake-useragent fails
            self.user_agent = 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        
        self.session.headers.update({
            'User-Agent': self.user_agent,
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1',
        })
        
        # Chrome options for Selenium
        self.chrome_options = Options()
        self.chrome_options.add_argument('--headless')
        self.chrome_options.add_argument('--no-sandbox')
        self.chrome_options.add_argument('--disable-dev-shm-usage')
        self.chrome_options.add_argument('--disable-gpu')
        self.chrome_options.add_argument(f'--user-agent={self.user_agent}')
    
    def scrape_price(self, product) -> Tuple[Optional[Decimal], str]:
        """Main method to scrape price with comprehensive error handling."""
        from .models import ScrapingLog
        
        start_time = time.time()
        
        # FIXED: Only include fields that exist in the ScrapingLog model
        log_entry = ScrapingLog.objects.create(
            product=product,
            user=product.user,  # Get user from the product
            status='failed',
            started_at=timezone.now()
            # Removed: user_agent_used and url fields since they don't exist
        )
        
        try:
            url = product.url.lower()
            price = None
            error_message = ""
            
            if 'amazon' in url:
                price = self.scrape_amazon_price(product.url)
                if not price:
                    error_message = "Could not extract price from Amazon page"
            elif 'flipkart' in url:
                price = self.scrape_flipkart_price(product.url)
                if not price:
                    error_message = "Could not extract price from Flipkart page"
            else:
                error_message = "Unsupported e-commerce site"
            
            # Update log entry with results
            log_entry.status = 'success' if price else 'failed'
            log_entry.scraped_price = price
            log_entry.response_time = time.time() - start_time
            log_entry.completed_at = timezone.now()
            log_entry.error_message = error_message
            log_entry.save()
            
            return price, log_entry.status
            
        except Exception as e:
            log_entry.error_message = str(e)
            log_entry.response_time = time.time() - start_time
            log_entry.completed_at = timezone.now()
            log_entry.save()
            
            logger.error(f"Error scraping price for {product.name}: {str(e)}")
            return None, 'failed'
    
    # Keep all other methods (scrape_amazon_price, scrape_flipkart_price, etc.) the same


class DataProcessor:
    """Data processing utility class using Pandas and NumPy."""
    
    @staticmethod
    def get_price_history_dataframe(product, days: int = 30) -> pd.DataFrame:
        """Get price history as a Pandas DataFrame for analysis."""
        from .models import PriceHistory
        
        end_date = timezone.now()
        start_date = end_date - timedelta(days=days)
        
        history = PriceHistory.objects.filter(
            product=product,
            recorded_at__gte=start_date,
            is_valid=True
        ).order_by('recorded_at')
        
        if not history.exists():
            return pd.DataFrame()
        
        data = []
        for record in history:
            data.append({
                'date': record.recorded_at.date(),
                'datetime': record.recorded_at,
                'price': float(record.price),
                'source': record.source
            })
        
        df = pd.DataFrame(data)
        if not df.empty:
            df['datetime'] = pd.to_datetime(df['datetime'])
            df.set_index('datetime', inplace=True)
            df.sort_index(inplace=True)
        
        return df
    
    @staticmethod
    def calculate_moving_averages(df: pd.DataFrame, windows: List[int] = [7, 14, 30]) -> pd.DataFrame:
        """Calculate moving averages using Pandas."""
        if df.empty:
            return df
        
        result_df = df.copy()
        
        for window in windows:
            if len(result_df) >= window:
                result_df[f'ma_{window}'] = result_df['price'].rolling(
                    window=window, min_periods=1
                ).mean()
        
        return result_df
    
    @staticmethod
    def calculate_price_statistics(df: pd.DataFrame) -> Dict[str, float]:
        """Calculate comprehensive price statistics using NumPy."""
        if df.empty or 'price' not in df.columns:
            return {}
        
        prices = df['price'].values
        
        stats = {
            'mean': np.mean(prices),
            'median': np.median(prices),
            'std': np.std(prices),
            'min': np.min(prices),
            'max': np.max(prices),
            'range': np.max(prices) - np.min(prices),
            'coefficient_of_variation': np.std(prices) / np.mean(prices) if np.mean(prices) > 0 else 0,
        }
        
        if len(prices) > 1:
            price_changes = np.diff(prices)
            stats.update({
                'volatility': np.std(price_changes),
                'avg_daily_change': np.mean(price_changes),
                'max_daily_increase': np.max(price_changes),
                'max_daily_decrease': np.min(price_changes),
            })
        
        return stats
    
    @staticmethod
    def get_chart_data_json(product, days: int = 30) -> str:
        """Get price history data formatted for Chart.js."""
        df = DataProcessor.get_price_history_dataframe(product, days)
        
        if df.empty:
            return json.dumps({'labels': [], 'prices': []})
        
        labels = [date.strftime('%Y-%m-%d') for date in df.index.date]
        prices = df['price'].tolist()
        
        return json.dumps({
            'labels': labels,
            'prices': prices,
            'product_name': product.name,
            'currency': product.currency
        })


class MLPredictor:
    """Machine Learning utility class for price and demand prediction."""
    
    def __init__(self):
        """Initialize ML models and scalers."""
        self.linear_model = LinearRegression()
        self.rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
        self.scaler = StandardScaler()
    
    def prepare_features(self, df: pd.DataFrame) -> Tuple[np.ndarray, np.ndarray]:
        """Prepare features for machine learning models."""
        if df.empty or len(df) < 5:
            return np.array([]), np.array([])
        
        df_features = df.copy()
        df_features['price_lag_1'] = df_features['price'].shift(1)
        df_features['price_lag_2'] = df_features['price'].shift(2)
        df_features['price_lag_3'] = df_features['price'].shift(3)
        
        df_features['price_ma_3'] = df_features['price'].rolling(3).mean()
        df_features['price_ma_7'] = df_features['price'].rolling(7).mean()
        df_features['price_std_3'] = df_features['price'].rolling(3).std()
        
        df_features['day_of_week'] = df_features.index.dayofweek
        df_features['day_of_month'] = df_features.index.day
        df_features['month'] = df_features.index.month
        
        df_features = df_features.dropna()
        
        if len(df_features) < 3:
            return np.array([]), np.array([])
        
        feature_columns = [
            'price_lag_1', 'price_lag_2', 'price_lag_3',
            'price_ma_3', 'price_ma_7', 'price_std_3',
            'day_of_week', 'day_of_month', 'month'
        ]
        
        X = df_features[feature_columns].values
        y = df_features['price'].values
        
        return X, y
    
    def predict_linear_regression(self, product, days_ahead: int = 7) -> List[Dict]:
        """Predict future prices using Linear Regression."""
        try:
            df = DataProcessor.get_price_history_dataframe(product, days=60)
            if df.empty:
                return []
            
            X, y = self.prepare_features(df)
            if len(X) == 0:
                return []
            
            X_scaled = self.scaler.fit_transform(X)
            
            if len(X_scaled) > 10:
                X_train, X_test, y_train, y_test = train_test_split(
                    X_scaled, y, test_size=0.2, random_state=42
                )
            else:
                X_train, X_test, y_train, y_test = X_scaled, X_scaled, y, y
            
            self.linear_model.fit(X_train, y_train)
            
            if len(X_test) > 0:
                y_pred_test = self.linear_model.predict(X_test)
                r2 = r2_score(y_test, y_pred_test)
                confidence = max(0, min(1, r2))
            else:
                confidence = 0.5
            
            predictions = []
            current_price = float(df['price'].iloc[-1])
            
            for i in range(days_ahead):
                if len(df) >= 3:
                    recent_prices = df['price'].tail(3).values
                    trend = np.mean(np.diff(recent_prices))
                    pred_price = current_price + (trend * (i + 1))
                else:
                    pred_price = current_price
                
                pred_price = max(current_price * 0.5, min(current_price * 2.0, pred_price))
                
                prediction_date = timezone.now().date() + timedelta(days=i+1)
                
                predictions.append({
                    'date': prediction_date,
                    'predicted_price': round(pred_price, 2),
                    'confidence_score': confidence,
                    'model_type': 'linear_regression'
                })
            
            return predictions
            
        except Exception as e:
            logger.error(f"Error in linear regression prediction: {str(e)}")
            return []
    
    def predict_demand(self, product) -> float:
        """Predict demand score based on price trends and volatility."""
        try:
            df = DataProcessor.get_price_history_dataframe(product, days=30)
            if df.empty:
                return 0.5
            
            if len(df) >= 2:
                price_trend = (df['price'].iloc[-1] - df['price'].iloc[0]) / df['price'].iloc
                trend_factor = max(0, 1 - price_trend)
            else:
                trend_factor = 0.5
            
            if len(df) >= 3:
                volatility = np.std(df['price']) / np.mean(df['price'])
                volatility_factor = max(0, 1 - volatility)
            else:
                volatility_factor = 0.5
            
            demand_score = (trend_factor * 0.6 + volatility_factor * 0.4)
            return max(0.1, min(0.9, demand_score))
            
        except Exception as e:
            logger.error(f"Error predicting demand: {str(e)}")
            return 0.5


class ChartGenerator:
    """Chart generation utility class using Matplotlib."""
    
    def __init__(self):
        """Initialize chart styling."""
        plt.style.use('default')
        plt.rcParams['figure.figsize'] = (12, 6)
        plt.rcParams['figure.dpi'] = 100
        plt.rcParams['font.size'] = 10
    
    def generate_price_trend_chart(self, product) -> str:
        """Generate a price trend chart using Matplotlib."""
        try:
            df = DataProcessor.get_price_history_dataframe(product, days=60)
            if df.empty:
                return self._create_no_data_chart("No price history available")
            
            fig, ax = plt.subplots(figsize=(12, 6))
            
            ax.plot(df.index, df['price'], linewidth=2, color='#2E86AB', label='Price', marker='o', markersize=3)
            
            df_with_ma = DataProcessor.calculate_moving_averages(df, [7, 14])
            if 'ma_7' in df_with_ma.columns:
                ax.plot(df_with_ma.index, df_with_ma['ma_7'], 
                       linewidth=1, color='#A23B72', alpha=0.7, label='7-day MA')
            if 'ma_14' in df_with_ma.columns:
                ax.plot(df_with_ma.index, df_with_ma['ma_14'], 
                       linewidth=1, color='#F18F01', alpha=0.7, label='14-day MA')
            
            if product.alert_threshold:
                ax.axhline(y=float(product.alert_threshold), color='red', 
                          linestyle='--', alpha=0.5, label='Alert Threshold')
            
            ax.set_title(f'Price Trend - {product.name}', fontsize=14, fontweight='bold')
            ax.set_xlabel('Date')
            ax.set_ylabel(f'Price ({product.currency})')
            ax.legend()
            ax.grid(True, alpha=0.3)
            
            ax.xaxis.set_major_formatter(mdates.DateFormatter('%m/%d'))
            ax.xaxis.set_major_locator(mdates.DayLocator(interval=7))
            plt.xticks(rotation=45)
            
            plt.tight_layout()
            return self._fig_to_base64(fig)
            
        except Exception as e:
            logger.error(f"Error generating price trend chart: {str(e)}")
            return self._create_error_chart("Error generating chart")
    
    def _fig_to_base64(self, fig) -> str:
        """Convert matplotlib figure to base64 string for web display."""
        buffer = io.BytesIO()
        fig.savefig(buffer, format='png', bbox_inches='tight', dpi=100)
        buffer.seek(0)
        image_png = buffer.getvalue()
        buffer.close()
        plt.close(fig)  # Important: close figure to free memory
        
        graphic = base64.b64encode(image_png)
        return graphic.decode('utf-8')
    
    def _create_no_data_chart(self, message: str) -> str:
        """Create a simple chart showing no data message."""
        fig, ax = plt.subplots(figsize=(8, 4))
        ax.text(0.5, 0.5, message, ha='center', va='center', fontsize=14)
        ax.set_xlim(0, 1)
        ax.set_ylim(0, 1)
        ax.axis('off')
        return self._fig_to_base64(fig)
    
    def _create_error_chart(self, message: str) -> str:
        """Create a simple chart showing error message."""
        fig, ax = plt.subplots(figsize=(8, 4))
        ax.text(0.5, 0.5, message, ha='center', va='center', fontsize=14, color='red')
        ax.set_xlim(0, 1)
        ax.set_ylim(0, 1)
        ax.axis('off')
        return self._fig_to_base64(fig)


# Utility functions
def calculate_price_change_percentage(product, days: int = 30) -> Optional[float]:
    """Calculate the percentage change in price over a specified period."""
    try:
        df = DataProcessor.get_price_history_dataframe(product, days)
        
        if df.empty or len(df) < 2:
            return None
        
        current_price = df['price'].iloc[-1]
        past_price = df['price'].iloc[0]
        
        if past_price == 0:
            return None
        
        return ((current_price - past_price) / past_price) * 100
        
    except Exception as e:
        logger.error(f"Error calculating price change: {str(e)}")
        return None


def check_alert_conditions(alert) -> bool:
    """Check if alert conditions are met and trigger notifications."""
    if alert.status != 'active':
        return False
    
    product = alert.product
    
    if not product.current_price:
        return False
    
    current_price = float(product.current_price)
    threshold = float(alert.threshold_value)
    
    triggered = False
    
    if alert.alert_type == 'price_drop' and current_price <= threshold:
        triggered = True
    elif alert.alert_type == 'price_increase' and current_price >= threshold:
        triggered = True
    
    if triggered:
        alert.status = 'triggered'
        alert.triggered_at = timezone.now()
        alert.save()
        
        send_alert_notification(alert)
        
        logger.info(f"Alert triggered for {product.name}: {alert.alert_type}")
        return True
    
    return False


def send_alert_notification(alert):
    """Send alert notifications via email."""
    product = alert.product
    user = alert.user
    
    try:
        subject = f'Price Alert: {product.name}'
        
        context = {
            'user': user,
            'product': product,
            'alert': alert,
            'current_price': product.current_price,
            'threshold': alert.threshold_value,
            'price_url': product.url,
        }
        
        try:
            html_message = render_to_string('tracker/email/price_alert.html', context)
            plain_message = strip_tags(html_message)
        except:
            plain_message = f"""
            Hello {user.first_name or user.username},
            
            Your price alert for "{product.name}" has been triggered!
            
            Alert Type: {alert.get_alert_type_display()}
            Current Price: {product.current_price} {product.currency}
            Your Threshold: {alert.threshold_value} {product.currency}
            
            View product: {product.url}
            
            Best regards,
            Price Tracker Team
            """
            html_message = None
        
        if alert.email_notification and user.email:
            send_mail(
                subject=subject,
                message=plain_message,
                from_email=getattr(settings, 'DEFAULT_FROM_EMAIL', 'noreply@example.com'),
                recipient_list=[user.email],
                html_message=html_message,
                fail_silently=False,
            )
            logger.info(f"Alert email sent to {user.email} for product {product.name}")
            
    except Exception as e:
        logger.error(f"Failed to send alert notification: {str(e)}")


def update_product_prices():
    """Update prices for all active products."""
    from .models import Product, PriceHistory
    
    scraper = WebScraper()
    active_products = Product.objects.filter(is_active=True)
    
    updated_count = 0
    failed_count = 0
    
    logger.info(f"Starting price update for {active_products.count()} products")
    
    for product in active_products:
        try:
            price, status = scraper.scrape_price(product)
            
            if price and status == 'success':
                old_price = product.current_price
                product.current_price = price
                product.last_scraped = timezone.now()
                product.save()
                
                PriceHistory.objects.create(
                    product=product,
                    price=price,
                    currency=product.currency,
                    source='automated_scraper'
                )
                
                updated_count += 1
                logger.info(f"Updated price for {product.name}: {old_price} -> {price}")
                
                for alert in product.alerts.filter(status='active'):
                    check_alert_conditions(alert)
                    
            else:
                failed_count += 1
                logger.warning(f"Failed to update price for {product.name}")
                
        except Exception as e:
            failed_count += 1
            logger.error(f"Error updating price for {product.name}: {str(e)}")
    
    logger.info(f"Price update completed: {updated_count} updated, {failed_count} failed")
    return updated_count, failed_count


def generate_predictions_for_product(product):
    """Generate ML predictions for a specific product."""
    from .models import DemandPrediction
    
    try:
        predictor = MLPredictor()
        
        linear_predictions = predictor.predict_linear_regression(product, days_ahead=7)
        
        prediction_count = 0
        
        for pred in linear_predictions:
            demand_score = predictor.predict_demand(product)
            
            prediction, created = DemandPrediction.objects.update_or_create(
                product=product,
                prediction_date=pred['date'],
                model_type=pred['model_type'],
                defaults={
                    'predicted_demand': demand_score,
                    'predicted_price': pred['predicted_price'],
                    'confidence_score': pred['confidence_score'],
                    'model_version': '1.0'
                }
            )
            
            if created:
                prediction_count += 1
        
        logger.info(f"Generated {prediction_count} predictions for {product.name}")
        return prediction_count
        
    except Exception as e:
        logger.error(f"Error generating predictions for {product.name}: {str(e)}")
        return 0



views.py


"""
Django views for the Price Tracker application with all missing functions.
"""

import json
import csv
from datetime import datetime, timedelta
from django.shortcuts import render, get_object_or_404, redirect
from django.contrib.auth.decorators import login_required
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib import messages
from django.http import JsonResponse, HttpResponse, Http404
from django.views.generic import ListView, DetailView, CreateView, UpdateView, DeleteView
from django.urls import reverse_lazy
from django.db.models import Q, Count, Avg, Max, Min
from django.utils import timezone
from django.core.paginator import Paginator
from django.contrib.auth.models import User
from django.contrib.auth import login, authenticate
from django.views.decorators.http import require_POST
from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.cache import cache_page
from django.core.exceptions import ValidationError
from django.db import transaction
from django.contrib import messages
from django.urls import reverse
import logging

# Local imports
from .models import Product, PriceHistory, DemandPrediction, PriceAlert, ScrapingLog
from .forms import ProductForm, AlertForm, UserRegistrationForm, ProductSearchForm, ExportForm
from .utils import (
    WebScraper, DataProcessor, ChartGenerator, MLPredictor,
    calculate_price_change_percentage, update_product_prices,
    generate_predictions_for_product
)

logger = logging.getLogger(__name__)


class DashboardView(LoginRequiredMixin, ListView):
    """Enhanced dashboard view with comprehensive analytics."""
    
    model = Product
    template_name = 'tracker/dashboard.html'
    context_object_name = 'products'
    paginate_by = 10
    
    def get_queryset(self):
        """Get products for the current user with annotations."""
        queryset = Product.objects.filter(user=self.request.user).annotate(
            price_history_count=Count('price_history'),
            avg_price=Avg('price_history__price'),
            latest_price_date=Max('price_history__recorded_at')
        )
        
        # Apply search filters
        search_form = ProductSearchForm(self.request.GET)
        if search_form.is_valid():
            search_query = search_form.cleaned_data.get('search_query')
            min_price = search_form.cleaned_data.get('min_price')
            max_price = search_form.cleaned_data.get('max_price')
            currency = search_form.cleaned_data.get('currency')
            is_active = search_form.cleaned_data.get('is_active')
            
            if search_query:
                queryset = queryset.filter(
                    Q(name__icontains=search_query) | 
                    Q(url__icontains=search_query)
                )
            
            if min_price:
                queryset = queryset.filter(current_price__gte=min_price)
            
            if max_price:
                queryset = queryset.filter(current_price__lte=max_price)
            
            if currency:
                queryset = queryset.filter(currency=currency)
            
            if is_active:
                is_active_bool = is_active == 'True'
                queryset = queryset.filter(is_active=is_active_bool)
        
        return queryset.order_by('-created_at')
    
    def get_context_data(self, **kwargs):
        """Add comprehensive context data."""
        context = super().get_context_data(**kwargs)
        
        # Add search form
        context['search_form'] = ProductSearchForm(self.request.GET)
        
        # Get user products for statistics
        user_products = Product.objects.filter(user=self.request.user)
        context['total_products'] = user_products.count()
        context['active_products'] = user_products.filter(is_active=True).count()
        
        # Fixed alert counting
        products_with_alerts = user_products.filter(
            alerts__status='active'
        ).distinct().count()
        context['products_with_alerts'] = products_with_alerts
        
        # Get recent price changes
        recent_changes = []
        for product in user_products.filter(current_price__isnull=False)[:5]:
            change = calculate_price_change_percentage(product, days=7)
            if change is not None:
                recent_changes.append({
                    'product': product,
                    'change_percentage': change,
                    'is_positive': change > 0,
                    'abs_change': abs(change)
                })
        
        context['recent_changes'] = sorted(
            recent_changes, 
            key=lambda x: x['abs_change'], 
            reverse=True
        )
        
        # Add scraping statistics
        today = timezone.now().date()
        context['today_scrapes'] = ScrapingLog.objects.filter(
            product__user=self.request.user,
            started_at__date=today
        ).count()
        
        context['successful_scrapes'] = ScrapingLog.objects.filter(
            product__user=self.request.user,
            started_at__date=today,
            status='success'
        ).count()
        
        return context


class ProductDetailView(LoginRequiredMixin, DetailView):
    """Product detail view with comprehensive analytics."""
    
    model = Product
    template_name = 'tracker/product_detail.html'
    context_object_name = 'product'
    
    def get_queryset(self):
        return Product.objects.filter(user=self.request.user)
    
    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        product = self.get_object()
        
        # Get price history
        context['price_history'] = PriceHistory.objects.filter(
            product=product,
            is_valid=True
        ).order_by('-recorded_at')[:30]
        
        # Calculate basic statistics
        if context['price_history']:
            prices = [float(ph.price) for ph in context['price_history']]
            context['min_price'] = min(prices)
            context['max_price'] = max(prices)
            context['avg_price'] = sum(prices) / len(prices)
            context['price_volatility'] = calculate_price_change_percentage(product, days=30)
        else:
            context['min_price'] = 0
            context['max_price'] = 0
            context['avg_price'] = 0
            context['price_volatility'] = None
        
        # Get active alerts
        context['active_alerts'] = PriceAlert.objects.filter(
            product=product,
            status='active'
        )
        
        # Get recent scraping logs
        context['recent_scrapes'] = ScrapingLog.objects.filter(
            product=product
        ).order_by('-started_at')[:10]
        
        # Get recent predictions
        context['recent_predictions'] = DemandPrediction.objects.filter(
            product=product
        ).order_by('-prediction_date')[:7]
        
        # Generate charts
        try:
            chart_generator = ChartGenerator()
            context['price_chart'] = chart_generator.generate_price_trend_chart(product)
        except Exception as e:
            logger.error(f"Error generating price chart: {str(e)}")
            context['price_chart'] = None
        
        return context


class ProductCreateView(LoginRequiredMixin, CreateView):
    """View for creating new products."""
    
    model = Product
    form_class = ProductForm
    template_name = 'tracker/product_form.html'
    success_url = reverse_lazy('tracker:dashboard')
    
    def form_valid(self, form):
        form.instance.user = self.request.user
        response = super().form_valid(form)
        
        messages.success(
            self.request, 
            f'Product "{form.instance.name}" added successfully! '
            'Use the "Update Price" button to fetch the current price.'
        )
        
        return response


class ProductUpdateView(LoginRequiredMixin, UpdateView):
    """View for updating existing products."""
    
    model = Product
    form_class = ProductForm
    template_name = 'tracker/product_form.html'
    
    def get_queryset(self):
        return Product.objects.filter(user=self.request.user)
    
    def get_success_url(self):
        return reverse_lazy('tracker:product_detail', kwargs={'pk': self.object.pk})
    
    def form_valid(self, form):
        response = super().form_valid(form)
        messages.success(self.request, f'Product "{form.instance.name}" updated successfully.')
        return response


class ProductDeleteView(LoginRequiredMixin, DeleteView):
    """View for deleting products."""
    
    model = Product
    template_name = 'tracker/product_confirm_delete.html'
    success_url = reverse_lazy('tracker:dashboard')
    
    def get_queryset(self):
        return Product.objects.filter(user=self.request.user)
    
    def delete(self, request, *args, **kwargs):
        product = self.get_object()
        messages.success(request, f'Product "{product.name}" deleted successfully.')
        return super().delete(request, *args, **kwargs)


@login_required
def update_price_manual(request, product_id):
    """Manual price update with proper parameter name."""
    product = get_object_or_404(Product, id=product_id, user=request.user)
    
    if request.method == 'POST':
        try:
            scraper = WebScraper()
            old_price = product.current_price
            
            messages.info(
                request, 
                f'Starting price update for "{product.name}". Please wait...'
            )
            
            price, status = scraper.scrape_price(product)
            
            if price and status == 'success':
                with transaction.atomic():
                    product.current_price = price
                    product.last_scraped = timezone.now()
                    product.save()
                    
                    PriceHistory.objects.create(
                        product=product,
                        price=price,
                        currency=product.currency,
                        source='manual_update'
                    )
                    
                    change_msg = ""
                    if old_price:
                        change = ((price - old_price) / old_price) * 100
                        change_msg = f" ({change:+.1f}% change)"
                    
                    messages.success(
                        request, 
                        f'Price updated successfully: {price} {product.currency}{change_msg}'
                    )
                    
                    logger.info(f"Manual price update successful for {product.name}: {price}")
            else:
                messages.error(
                    request, 
                    f'Failed to update price for "{product.name}". '
                    'The website might be blocking requests or the product page structure has changed.'
                )
                logger.warning(f"Manual price update failed for {product.name}")
                        
        except Exception as e:
            logger.error(f"Error in manual price update: {str(e)}")
            messages.error(request, f'Error updating price: {str(e)}')
    
    return redirect('tracker:product_detail', pk=product_id)


@login_required
def bulk_update_prices(request):
    """Bulk update prices for all user's active products."""
    if request.method == 'POST':
        user_products = Product.objects.filter(user=request.user, is_active=True)
        
        if not user_products.exists():
            messages.warning(request, 'No active products to update.')
            return redirect('tracker:dashboard')
        
        updated_count = 0
        failed_count = 0
        scraper = WebScraper()
        
        messages.info(
            request, 
            f'Starting bulk update for {user_products.count()} products. This may take a few minutes...'
        )
        
        for product in user_products:
            try:
                price, status = scraper.scrape_price(product)
                
                if price and status == 'success':
                    old_price = product.current_price
                    product.current_price = price
                    product.last_scraped = timezone.now()
                    product.save()
                    
                    PriceHistory.objects.create(
                        product=product,
                        price=price,
                        currency=product.currency,
                        source='bulk_update'
                    )
                    
                    updated_count += 1
                    logger.info(f"Bulk update successful for {product.name}: {price}")
                else:
                    failed_count += 1
                    logger.warning(f"Bulk update failed for {product.name}")
                    
                import time
                time.sleep(2)
                    
            except Exception as e:
                failed_count += 1
                logger.error(f"Error in bulk update for {product.name}: {str(e)}")
        
        if updated_count > 0:
            messages.success(
                request, 
                f'Bulk update completed! {updated_count} products updated successfully.'
            )
        
        if failed_count > 0:
            messages.warning(
                request, 
                f'{failed_count} products failed to update. Check the logs for details.'
            )
        
        logger.info(f"Bulk update completed: {updated_count} updated, {failed_count} failed")
    
    return redirect('tracker:dashboard')


@login_required
def generate_predictions(request, product_id):
    """Manual prediction generation endpoint."""
    try:
        product = get_object_or_404(Product, id=product_id, user=request.user)
        
        prediction_count = generate_predictions_for_product(product)
        
        if prediction_count > 0:
            messages.success(
                request, 
                f'Generated {prediction_count} new predictions for {product.name}.'
            )
        else:
            messages.warning(
                request, 
                f'Could not generate predictions for {product.name}. '
                'Make sure the product has sufficient price history.'
            )
    
    except Exception as e:
        logger.error(f"Error generating predictions: {str(e)}")
        messages.error(request, f'Error generating predictions: {str(e)}')
    
    return redirect('tracker:product_detail', pk=product_id)


@login_required
@require_POST
def delete_alert(request, alert_id):
    """AJAX endpoint to delete a price alert."""
    try:
        alert = get_object_or_404(PriceAlert, id=alert_id, user=request.user)
        product_name = alert.product.name
        alert.delete()
        
        return JsonResponse({
            'status': 'success',
            'message': f'Alert for "{product_name}" deleted successfully.'
        })
        
    except Exception as e:
        logger.error(f"Error deleting alert: {str(e)}")
        return JsonResponse({
            'status': 'error',
            'message': 'Failed to delete alert.'
        }, status=500)


@login_required
@require_POST
def toggle_product_status(request, product_id):
    """AJAX endpoint to toggle product status."""
    try:
        product = get_object_or_404(Product, id=product_id, user=request.user)
        
        product.is_active = not product.is_active
        product.save()
        
        status = 'activated' if product.is_active else 'deactivated'
        
        return JsonResponse({
            'status': 'success',
            'is_active': product.is_active,
            'message': f'Product {status} successfully.'
        })
        
    except Exception as e:
        logger.error(f"Error toggling product status: {str(e)}")
        return JsonResponse({
            'status': 'error',
            'message': 'Failed to update product status.'
        }, status=500)


@login_required
def chart_data_api(request, product_id):
    """API endpoint for getting chart data in JSON format."""
    product = get_object_or_404(Product, id=product_id, user=request.user)
    days = int(request.GET.get('days', 30))
    
    try:
        chart_data_json = DataProcessor.get_chart_data_json(product, days)
        return JsonResponse(json.loads(chart_data_json))
    except Exception as e:
        logger.error(f"Error getting chart data: {str(e)}")
        return JsonResponse({'error': 'Failed to get chart data'}, status=500)


@login_required
def add_alert(request, product_id):
    """View for adding price alerts to products."""
    product = get_object_or_404(Product, id=product_id, user=request.user)
    
    if request.method == 'POST':
        form = AlertForm(request.POST)
        if form.is_valid():
            try:
                alert = form.save(commit=False)
                alert.user = request.user
                alert.product = product
                alert.save()
                
                messages.success(
                    request, 
                    f'Alert created successfully for {product.name}!'
                )
                return redirect('tracker:product_detail', pk=product_id)
            except ValidationError as e:
                messages.error(request, f'Error creating alert: {str(e)}')
        else:
            messages.error(request, 'Please correct the errors below.')
    else:
        form = AlertForm()
    
    return render(request, 'tracker/alert_form.html', {
        'form': form,
        'product': product
    })


@login_required
def export_data(request):
    """Data export view."""
    if request.method == 'POST':
        form = ExportForm(request.POST)
        if form.is_valid():
            export_format = form.cleaned_data['export_format']
            
            products = Product.objects.filter(user=request.user)
            
            if export_format == 'csv':
                return export_to_csv(request, products)
            elif export_format == 'json':
                return export_to_json(request, products)
    else:
        form = ExportForm()
    
    return render(request, 'tracker/export.html', {'form': form})


def export_to_csv(request, products):
    """Export product data to CSV format."""
    response = HttpResponse(content_type='text/csv')
    response['Content-Disposition'] = f'attachment; filename="products_{timezone.now().strftime("%Y%m%d")}.csv"'
    
    writer = csv.writer(response)
    writer.writerow(['Product ID', 'Name', 'URL', 'Current Price', 'Currency', 'Is Active', 'Created At'])
    
    for product in products:
        writer.writerow([
            product.id,
            product.name,
            product.url,
            product.current_price,
            product.currency,
            product.is_active,
            product.created_at.strftime('%Y-%m-%d %H:%M:%S')
        ])
    
    return response


def export_to_json(request, products):
    """Export product data to JSON format."""
    data = []
    
    for product in products:
        product_data = {
            'id': str(product.id),
            'name': product.name,
            'url': product.url,
            'current_price': float(product.current_price) if product.current_price else None,
            'currency': product.currency,
            'is_active': product.is_active,
            'created_at': product.created_at.isoformat(),
        }
        data.append(product_data)
    
    response = HttpResponse(json.dumps(data, indent=2), content_type='application/json')
    response['Content-Disposition'] = f'attachment; filename="products_{timezone.now().strftime("%Y%m%d")}.json"'
    
    return response


def register(request):
    """User registration view."""
    if request.method == 'POST':
        form = UserRegistrationForm(request.POST)
        if form.is_valid():
            try:
                user = form.save()
                login(request, user)
                messages.success(request, 'Account created successfully!')
                return redirect('tracker:dashboard')
            except Exception as e:
                logger.error(f"Registration error: {str(e)}")
                messages.error(request, 'Registration failed. Please try again.')
    else:
        form = UserRegistrationForm()
    
    return render(request, 'tracker/register.html', {'form': form})


@login_required
def profile(request):
    """User profile view with statistics."""
    user = request.user
    
    user_products = Product.objects.filter(user=user)
    context = {
        'user': user,
        'total_products': user_products.count(),
        'active_products': user_products.filter(is_active=True).count(),
    }
    
    return render(request, 'tracker/profile.html', context)


# API views
@login_required
def api_products(request):
    """REST API endpoint for getting user's products."""
    products = Product.objects.filter(user=request.user)
    
    data = []
    for product in products:
        data.append({
            'id': str(product.id),
            'name': product.name,
            'current_price': float(product.current_price) if product.current_price else None,
            'currency': product.currency,
            'is_active': product.is_active,
            'created_at': product.created_at.isoformat(),
        })
    
    return JsonResponse({'products': data})


@login_required
def api_product_predictions(request, product_id):
    """REST API endpoint for getting product predictions."""
    product = get_object_or_404(Product, id=product_id, user=request.user)
    
    predictions = DemandPrediction.objects.filter(
        product=product
    ).order_by('-prediction_date')[:7]
    
    data = []
    for pred in predictions:
        data.append({
            'date': pred.prediction_date.isoformat(),
            'predicted_demand': pred.predicted_demand,
            'predicted_price': float(pred.predicted_price) if pred.predicted_price else None,
            'confidence_score': pred.confidence_score,
            'model_type': pred.model_type,
        })
    
    return JsonResponse({'predictions': data})

@login_required
def update_price_manual(request, product_id):
    """Manual price update with proper parameter name."""
    product = get_object_or_404(Product, id=product_id, user=request.user)
    
    if request.method == 'POST':
        try:
            scraper = WebScraper()
            old_price = product.current_price
            
            messages.info(
                request, 
                f'Starting price update for "{product.name}". Please wait...'
            )
            
            price, status = scraper.scrape_price(product)
            
            if price and status == 'success':
                with transaction.atomic():
                    product.current_price = price
                    product.last_scraped = timezone.now()
                    product.save()
                    
                    # Create price history record
                    PriceHistory.objects.create(
                        product=product,
                        price=price,
                        currency=product.currency,
                        source='manual_update'
                    )
                    
                    change_msg = ""
                    if old_price:
                        change = ((price - old_price) / old_price) * 100
                        change_msg = f" ({change:+.1f}% change)"
                    
                    messages.success(
                        request, 
                        f'Price updated successfully: {price} {product.currency}{change_msg}'
                    )
                    
                    logger.info(f"Manual price update successful for {product.name}: {price}")
            else:
                messages.error(
                    request, 
                    f'Failed to update price for "{product.name}". '
                    'Please try again later.'
                )
                logger.warning(f"Manual price update failed for {product.name}")
                        
        except Exception as e:
            logger.error(f"Error in manual price update: {str(e)}")
            messages.error(request, f'Error updating price: Please try again.')
    
    return redirect('tracker:product_detail', pk=product_id)


models.py


"""
Django models for the Price Tracker application.

This module defines the database models for tracking products, price history,
and demand predictions.
"""

from django.db import models
from django.contrib.auth.models import User
from django.core.validators import MinValueValidator, URLValidator
from django.utils import timezone
import uuid


class Product(models.Model):
    """
    Model to store product information for price tracking.
    
    This model represents a product that users want to track for price changes.
    It stores basic product information and tracking preferences.
    """
    
    # Product identification
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    name = models.CharField(max_length=200, help_text="Product name")
    url = models.URLField(validators=[URLValidator()], help_text="Product URL from Amazon/Flipkart")
    
    # Current price information
    current_price = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        null=True, 
        blank=True,
        help_text="Current price of the product"
    )
    currency = models.CharField(max_length=3, default='INR', help_text="Currency code")
    
    # Tracking preferences
    alert_threshold = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        null=True, 
        blank=True,
        help_text="Price threshold for alerts"
    )
    is_active = models.BooleanField(default=True, help_text="Whether to track this product")
    
    # Metadata
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    last_scraped = models.DateTimeField(null=True, blank=True)
    
    # User relationship
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='products')
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = "Product"
        verbose_name_plural = "Products"
    
    def __str__(self):
        return f"{self.name} - {self.current_price} {self.currency}"
    
    @property
    def price_change_percentage(self):
        """Calculate the percentage change in price over the last 30 days."""
        from .utils import calculate_price_change_percentage
        return calculate_price_change_percentage(self)
    
    @property
    def is_price_dropped(self):
        """Check if current price is below alert threshold."""
        if self.alert_threshold and self.current_price:
            return self.current_price < self.alert_threshold
        return False


class PriceHistory(models.Model):
    """
    Model to store historical price data for products.
    
    This model tracks price changes over time, enabling trend analysis
    and price prediction using machine learning algorithms.
    """
    
    id = models.BigAutoField(primary_key=True)
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='price_history')
    
    # Price data
    price = models.DecimalField(max_digits=10, decimal_places=2)
    currency = models.CharField(max_length=3, default='INR')
    
    # Timestamp
    recorded_at = models.DateTimeField(default=timezone.now)
    
    # Additional metadata
    source = models.CharField(max_length=50, default='scraper', help_text="Source of price data")
    is_valid = models.BooleanField(default=True, help_text="Whether this price data is valid")
    
    class Meta:
        ordering = ['-recorded_at']
        verbose_name = "Price History"
        verbose_name_plural = "Price History"
        # Ensure unique price records per product per day
        unique_together = ['product', 'recorded_at']
    
    def __str__(self):
        return f"{self.product.name} - {self.price} {self.currency} at {self.recorded_at}"
    
    @property
    def date(self):
        """Return just the date part of the timestamp."""
        return self.recorded_at.date()


class DemandPrediction(models.Model):
    """
    Model to store demand predictions for products.
    
    This model stores machine learning predictions for future demand
    and price trends, helping users make informed decisions.
    """
    
    id = models.BigAutoField(primary_key=True)
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='demand_predictions')
    
    # Prediction data
    predicted_demand = models.FloatField(help_text="Predicted demand score")
    predicted_price = models.DecimalField(
        max_digits=10, 
        decimal_places=2, 
        null=True, 
        blank=True,
        help_text="Predicted price"
    )
    confidence_score = models.FloatField(
        default=0.0,
        validators=[MinValueValidator(0.0)],
        help_text="Confidence score for the prediction (0-1)"
    )
    
    # Prediction period
    prediction_date = models.DateField(help_text="Date for which prediction is made")
    created_at = models.DateTimeField(auto_now_add=True)
    
    # Model metadata
    model_type = models.CharField(
        max_length=50, 
        default='linear_regression',
        help_text="Type of ML model used for prediction"
    )
    model_version = models.CharField(max_length=20, default='1.0')
    
    class Meta:
        ordering = ['-prediction_date']
        verbose_name = "Demand Prediction"
        verbose_name_plural = "Demand Predictions"
        unique_together = ['product', 'prediction_date', 'model_type']
    
    def __str__(self):
        return f"{self.product.name} - {self.predicted_demand:.2f} demand on {self.prediction_date}"


class PriceAlert(models.Model):
    """
    Model to store user price alerts and notifications.
    
    This model manages user alerts for price drops and sends
    notifications when conditions are met.
    """
    
    ALERT_TYPES = [
        ('price_drop', 'Price Drop'),
        ('price_increase', 'Price Increase'),
        ('demand_spike', 'Demand Spike'),
    ]
    
    STATUS_CHOICES = [
        ('active', 'Active'),
        ('triggered', 'Triggered'),
        ('disabled', 'Disabled'),
    ]
    
    id = models.BigAutoField(primary_key=True)
    user = models.ForeignKey(User, on_delete=models.CASCADE, related_name='alerts')
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='alerts')
    
    # Alert configuration
    alert_type = models.CharField(max_length=20, choices=ALERT_TYPES, default='price_drop')
    threshold_value = models.DecimalField(max_digits=10, decimal_places=2)
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default='active')
    
    # Notification settings
    email_notification = models.BooleanField(default=True)
    web_notification = models.BooleanField(default=True)
    
    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True)
    triggered_at = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        ordering = ['-created_at']
        verbose_name = "Price Alert"
        verbose_name_plural = "Price Alerts"
    
    def __str__(self):
        return f"{self.user.username} - {self.product.name} {self.alert_type} alert"
    
    def check_and_trigger(self):
        """Check if alert conditions are met and trigger if necessary."""
        from .utils import check_alert_conditions
        return check_alert_conditions(self)


class ScrapingLog(models.Model):
    """
    Model to log scraping activities and errors.
    
    This model helps track scraping performance, errors, and
    provides debugging information for web scraping operations.
    """
    
    STATUS_CHOICES = [
        ('success', 'Success'),
        ('failed', 'Failed'),
        ('partial', 'Partial Success'),
    ]
    
    id = models.BigAutoField(primary_key=True)
    product = models.ForeignKey(Product, on_delete=models.CASCADE, related_name='scraping_logs')
    
    # Scraping results
    status = models.CharField(max_length=20, choices=STATUS_CHOICES)
    scraped_price = models.DecimalField(max_digits=10, decimal_places=2, null=True, blank=True)
    error_message = models.TextField(blank=True, null=True)
    
    # Performance metrics
    response_time = models.FloatField(null=True, blank=True, help_text="Response time in seconds")
    retry_count = models.IntegerField(default=0)
    
    # Timestamps
    started_at = models.DateTimeField(auto_now_add=True)
    completed_at = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        ordering = ['-started_at']
        verbose_name = "Scraping Log"
        verbose_name_plural = "Scraping Logs"
    
    def __str__(self):
        return f"{self.product.name} - {self.status} at {self.started_at}"
    
    @property
    def duration(self):
        """Calculate scraping duration."""
        if self.completed_at:
            return (self.completed_at - self.started_at).total_seconds()
        return None

